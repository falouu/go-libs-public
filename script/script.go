package script

import (
	"errors"
	"fmt"
	"io"
	"maps"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"

	"github.com/posener/complete"

	"github.com/alecthomas/kong"
	"github.com/falouu/go-libs-public/b"
	log "github.com/sirupsen/logrus"
	"github.com/willabides/kongplete"
)

type Script interface {
	// Dir directory where *.go script (with main() method) is located. Absolute path
	Dir() string
	// ScriptFileName filename of *.go script (with main() method)
	ScriptFileName() string
	// ScriptAlias returns script alias that is used as app name in help text, and also installed by GetInstallCompletionsScript
	// as an alias user can run and receive completions
	ScriptAlias() string
	// Cwd directory from where go script was called
	Cwd() string
	// RunCommand run command selected by Kong CLI based on command line arguments
	RunCommand(context ...any) error
	// GetInstallCompletionsScript returns script lines you can execute in bash, or put in .bashrc file to have an alias, and autocompletions for
	// this script
	GetInstallCompletionsScript() string
	// PrintUsage print usage - specific for app arguments provided
	PrintUsage()
	// PrintAppUsageAndExit print usage and exit - not specific to arguments provided - just like running 'app --help'
	PrintAppUsageAndExit()
}

// InputEnvVar Name of environment variables the caller can provide to influence the script.
// It's needed for configuration that needs to be passed from outside of the Go program.
// Parameters, to which Go program has no reasonable access. These parameters are meant to be generated by a script
// wrapper (usually in bash), or the script shebang line.
type InputEnvVar string

const (
	// APP_CWD actual current directory from the perspective of the user. This info is needed because when script is run using
	// 'go run' command, the current directory may be messed up
	APP_CWD InputEnvVar = "APP_CWD"
	// APP_ARG_0 actual argument 0 - file path the user provided to run the script
	APP_ARG_0 InputEnvVar = "APP_ARG_0"
	// APP_SCRIPTPATH path to the script you want to use for subsequent runs (used for example to generate alias in
	// --install-completions command). Defaults to absolute version of APP_ARG_0
	APP_SCRIPTPATH InputEnvVar = "APP_SCRIPTPATH"
)

type Plugins = kong.Plugins
type Vars = kong.Vars

type Writers struct {
	Stdout io.Writer
	Stderr io.Writer
}

// Options See defaultOptions for defaults
type Options struct {
	// command line options specification, as accepted by kong library
	CLI             interface{}
	Description     string
	DynamicCommands DynamicCommands
	// additional structs for CLI, they will be merged with CLI
	Plugins Plugins
	// map of variables you can use in a subset of CLI / Plugins tags (default, enum, help) in the form of ${varName}
	Vars Vars
	// Writers change stdout and stderr targets. Useful for testing.
	Writers Writers
	// ExitFunc custom "exit program in case of parsing error" function. Default os.Exit. Useful for testing
	ExitFunc func(code int)

	// Used for predicting script args in terminal.
	// map of predictor-name -> predictor. To use them, include `predictor:"name"` in kong struct field tag.
	//  Check kongplete README for info
	Predictors map[string]complete.Predictor
	bind       *bindToInterface
}

// This is the only way to be able to use interface arguments in command Run(args).
// `RunCommand(someStruct)` works only if the the command `Run(arg)` method has arg of `someStruct` type specifically,
// not an interface which `someStruct` implements.
//
// use it like this:
//
//	BindToInterface(&interfaceImplementation, (*InterfaceType)(nil))
func (o *Options) BindToInterface(impl, iface any) {
	// TODO: check if value implements iface
	o.bind = &bindToInterface{
		Interface:      iface,
		Implementation: impl,
	}
}

func (o Options) GetDefaults() *Options {
	copy := defaultOptions
	return &copy
}

func InitCustom(modifyOptions func(options *Options)) (Script, error) {
	options := defaultOptions
	modifyOptions(&options)
	return initScript(&options)
}

func Init() (Script, error) {
	return initScript(&defaultOptions)
}

func JustRun(fun runFunc) {
	if _, err := Init(); err != nil {
		log.Panic(err)
	}
	os.Exit(fun())
}

type runFunc func() (exitCode int)

var defaultOptions = Options{
	CLI:             &struct{}{},
	DynamicCommands: DynamicCommands{},
	Vars:            Vars{},
	Writers: Writers{
		Stdout: os.Stdout,
		Stderr: os.Stderr,
	},
	Plugins:    Plugins{},
	Predictors: map[string]complete.Predictor{},
}

// old shebang, worked fine in the past, but stopped working on macos
// var shebang = `///bin/true; export APP_CWD="$(pwd)" && cd "$(dirname "$0")" && exec /usr/bin/env go run "$0" "$@"`

// this shebang worked better on macos as of 2024-08, than the one above. Also works on ubuntu as of 2024-08
var shebang = fmt.Sprintf(``+
	`/// 2>/dev/null; `+
	`export %v="$(pwd)" && `+
	`cd "$(dirname "$0")" && `+
	`exec go run "$(basename "$0")" "$@"`,
	APP_CWD)

func initScript(options *Options) (Script, error) {

	file, err := getScriptFilepath()
	if err != nil {
		return nil, b.Wrap(err, "Cannot determine script filepath")
	}

	cwd, err := fixCwd()
	if err != nil {
		return nil, err
	}

	var cli struct {
		kong.Plugins
		InstallCompletions InstallCompletions `short:"i" help:"install shell completions"`
		LogLevel           string             `help:"Set log level"`
	}

	appName, appPath := getAppNameAndPath(cwd, file)

	appScriptpath := os.Getenv(string(APP_SCRIPTPATH))
	if err := os.Unsetenv(string(APP_SCRIPTPATH)); err != nil {
		return nil, err
	}
	if appScriptpath == "" {
		appScriptpath = appPath
	}

	script := script{
		filepath:      file,
		cwd:           cwd,
		name:          appName,
		appScriptpath: appScriptpath,
	}

	cli.Plugins = append(kong.Plugins{options.CLI}, options.Plugins...)
	kongOptions := []kong.Option{
		kong.Description(options.Description),
		kong.BindTo(&script, (*Script)(nil)),
		kong.UsageOnError(),
		kong.Name(appName),
		kong.Writers(options.Writers.Stdout, options.Writers.Stderr),
		options.Vars,
	}
	kongOptions = append(kongOptions, options.DynamicCommands.toKong()...)
	if options.ExitFunc != nil {
		kongOptions = append(kongOptions, kong.Exit(options.ExitFunc))
	}

	if options.bind != nil {
		kongOptions = append(kongOptions, kong.BindTo(options.bind.Implementation, options.bind.Interface))
	}

	kongParser := kong.Must(&cli, kongOptions...)

	// if err := kongCtx.Validate(); err != nil {
	// 	return nil, err
	// }

	predictors := maps.Clone(options.DynamicCommands.Predictors())
	maps.Copy(predictors, options.Predictors)

	kongplete.Complete(kongParser, kongplete.WithPredictors(predictors))

	script.kongCtx, err = kongParser.Parse(os.Args[1:])
	kongParser.FatalIfErrorf(err)

	if cli.LogLevel != "" {
		level, err := log.ParseLevel(cli.LogLevel)
		if err != nil {
			return nil, err
		}
		log.SetLevel(level)
	}

	log.Debug("script path: " + file)
	log.Debug("cwd: ", cwd)
	log.Debug("log level: " + log.GetLevel().String())

	return &script, nil
}

type script struct {
	// name is used for example in help text - it should be equal to real command the user called
	// it will also be used as an alias in completion script
	name string
	// absolute path to go script (with main() method)
	filepath string
	// absoulte path to the script wrapper which should be used for subsequent runs of this script
	appScriptpath string
	// current directory from user, who called the script, perspective
	cwd     string
	kongCtx *kong.Context
}

func (s *script) Dir() string {
	return filepath.Dir(s.filepath)
}

func (s *script) ScriptFileName() string {
	return filepath.Base(s.filepath)
}

func (s *script) Cwd() string {
	return s.cwd
}

func (s *script) RunCommand(context ...any) error {
	return s.kongCtx.Run(context...)
}

func (s *script) GetInstallCompletionsScript() string {
	path := resolveHome(s.appScriptpath)
	return "" +
		"alias " + s.name + "='" + path + "'\n" +
		"complete -C \"" + path + "\" " + s.name + "\n"
}

func (s *script) ScriptAlias() string {
	return s.name
}

func (s *script) PrintUsage() {
	s.kongCtx.PrintUsage(false)
}

func (s *script) PrintAppUsageAndExit() {
	_, err := s.kongCtx.Parse([]string{"--help"})
	s.kongCtx.FatalIfErrorf(err)
}

type InstallCompletions bool

func (f InstallCompletions) BeforeReset(script Script) error {
	fmt.Println("# To get command and params completions, execute:\n" +
		script.GetInstallCompletionsScript() +
		"# Add it to .bashrc for permanent effect")
	os.Exit(0)
	return nil
}

func getScriptFilepath() (string, error) {
	rpc := make([]uintptr, 100)
	n := runtime.Callers(1, rpc)
	if n < 1 {
		return "", errors.New("no frames returned")
	}

	frames := runtime.CallersFrames(rpc)

	more := true
	for more {
		var f runtime.Frame
		f, more = frames.Next()
		// "runtime.goexit" -> f.Function in tests
		if strings.HasPrefix(f.Function, "main.") {
			return f.File, nil
		}
		// for tests
		if strings.HasSuffix(f.File, "_test.go") {
			return f.File, nil
		}
	}

	return "", errors.New("cannot find frame with 'main' package")
}

var goRunBuildDirDetectPattern = regexp.MustCompile("go-build[0-9]")

func fixCwd() (string, error) {
	cwd, cwdFound := os.LookupEnv(string(APP_CWD))
	os.Unsetenv(string(APP_CWD))
	if !cwdFound {
		origCwd, err := os.Getwd()
		if err != nil {
			return "", b.Wrap(err, "Cannot obtain cwd and %v env var is missing", APP_CWD)
		}
		if goRunBuildDirDetectPattern.MatchString(os.Args[0]) {
			return "", fmt.Errorf("It looks like you run *.go script directly without building a binary. "+
				"You can do that, but you have to set %v env var, which is not found. "+
				"To fix that, add proper first line in your script:\n\n%v\n\nset executable flag:\n\n"+
				"chmod +x <your script>.go\n\n"+
				"and run it directly:\n\n./<your script>.go", APP_CWD, shebang)
		}
		cwd = origCwd
	} else {
		if err := os.Chdir(cwd); err != nil {
			return "", b.Wrap(err, "Cannot set working directory to directory provided by %v=%v", APP_CWD, cwd)
		}
	}
	return cwd, nil
}

func resolveHome(path string) string {
	home, err := os.UserHomeDir()
	if err != nil {
		return path
	}
	rel, err := filepath.Rel(home, path)
	if err != nil {
		return path
	}
	if strings.HasPrefix(rel, ".."+string(filepath.Separator)) {
		return path
	}
	return "${HOME}/" + rel
}

func getAppNameAndPath(cwd string, goScriptPath string) (name string, pathAbs string) {
	arg0 := os.Getenv(string(APP_ARG_0))
	os.Unsetenv(string(APP_ARG_0))
	if arg0 == "" {
		arg0 = os.Args[0]
		pathAbs = goScriptPath
	} else {
		pathAbs = arg0
		if !filepath.IsAbs(pathAbs) {
			pathAbs = filepath.Join(cwd, pathAbs)
		}
		pathAbs = filepath.Clean(pathAbs)
	}

	name = filepath.Base(arg0)
	return
}

type bindToInterface struct {
	Interface      any
	Implementation any
}
